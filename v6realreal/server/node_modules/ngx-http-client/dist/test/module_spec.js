/**
 * @license
 * Copyright Google Inc. All Rights Reserved.JsonpCallbackContext
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import 'rxjs/add/operator/map';
import { TestBed } from '@angular/core/testing';
import { HttpClient } from '../src/client';
import { HTTP_INTERCEPTORS } from '../src/interceptor';
import { HttpResponse } from '../src/response';
import { HttpTestingController } from '../testing/src/api';
import { HttpClientTestingModule } from '../testing/src/module';
var TestInterceptor = /** @class */ (function () {
    function TestInterceptor(value) {
        this.value = value;
    }
    TestInterceptor.prototype.intercept = function (req, delegate) {
        var _this = this;
        var existing = req.headers.get('Intercepted');
        var next = !!existing ? existing + ',' + this.value : this.value;
        req = req.clone({ setHeaders: { 'Intercepted': next } });
        return delegate.handle(req).map(function (event) {
            if (event instanceof HttpResponse) {
                var existing_1 = event.headers.get('Intercepted');
                var next_1 = !!existing_1 ? existing_1 + ',' + _this.value : _this.value;
                return event.clone({ headers: event.headers.set('Intercepted', next_1) });
            }
            return event;
        });
    };
    return TestInterceptor;
}());
var InterceptorA = /** @class */ (function (_super) {
    __extends(InterceptorA, _super);
    function InterceptorA() {
        return _super.call(this, 'A') || this;
    }
    return InterceptorA;
}(TestInterceptor));
var InterceptorB = /** @class */ (function (_super) {
    __extends(InterceptorB, _super);
    function InterceptorB() {
        return _super.call(this, 'B') || this;
    }
    return InterceptorB;
}(TestInterceptor));
export function main() {
    describe('HttpClientModule', function () {
        var injector;
        beforeEach(function () {
            injector = TestBed.configureTestingModule({
                imports: [HttpClientTestingModule],
                providers: [
                    { provide: HTTP_INTERCEPTORS, useClass: InterceptorA, multi: true },
                    { provide: HTTP_INTERCEPTORS, useClass: InterceptorB, multi: true },
                ],
            });
        });
        it('initializes HttpClient properly', function (done) {
            injector.get(HttpClient).get('/test', { responseType: 'text' }).subscribe(function (value) {
                expect(value).toBe('ok!');
                done();
            });
            injector.get(HttpTestingController).expectOne('/test').flush('ok!');
        });
        it('intercepts outbound responses in the order in which interceptors were bound', function (done) {
            injector.get(HttpClient)
                .get('/test', { observe: 'response', responseType: 'text' })
                .subscribe(function (value) { return done(); });
            var req = injector.get(HttpTestingController).expectOne('/test');
            expect(req.request.headers.get('Intercepted')).toEqual('A,B');
            req.flush('ok!');
        });
        it('intercepts inbound responses in the right (reverse binding) order', function (done) {
            injector.get(HttpClient)
                .get('/test', { observe: 'response', responseType: 'text' })
                .subscribe(function (value) {
                expect(value.headers.get('Intercepted')).toEqual('B,A');
                done();
            });
            injector.get(HttpTestingController).expectOne('/test').flush('ok!');
        });
    });
}
//# sourceMappingURL=module_spec.js.map