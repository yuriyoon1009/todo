/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HttpHeaders } from '../src/headers';
import { HttpRequest } from '../src/request';
import { HttpXsrfCookieExtractor, HttpXsrfInterceptor } from '../src/xsrf';
import { HttpClientTestingBackend } from '../testing/src/backend';
var SampleTokenExtractor = /** @class */ (function () {
    function SampleTokenExtractor(token) {
        this.token = token;
    }
    SampleTokenExtractor.prototype.getToken = function () { return this.token; };
    return SampleTokenExtractor;
}());
export function main() {
    describe('HttpXsrfInterceptor', function () {
        var backend;
        var interceptor = new HttpXsrfInterceptor(new SampleTokenExtractor('test'), 'X-XSRF-TOKEN');
        beforeEach(function () { backend = new HttpClientTestingBackend(); });
        it('applies XSRF protection to outgoing requests', function () {
            interceptor.intercept(new HttpRequest('POST', '/test', {}), backend).subscribe();
            var req = backend.expectOne('/test');
            expect(req.request.headers.get('X-XSRF-TOKEN')).toEqual('test');
            req.flush({});
        });
        it('does not apply XSRF protection when request is a GET', function () {
            interceptor.intercept(new HttpRequest('GET', '/test'), backend).subscribe();
            var req = backend.expectOne('/test');
            expect(req.request.headers.has('X-XSRF-TOKEN')).toEqual(false);
            req.flush({});
        });
        it('does not apply XSRF protection when request is a HEAD', function () {
            interceptor.intercept(new HttpRequest('HEAD', '/test'), backend).subscribe();
            var req = backend.expectOne('/test');
            expect(req.request.headers.has('X-XSRF-TOKEN')).toEqual(false);
            req.flush({});
        });
        it('does not overwrite existing header', function () {
            interceptor
                .intercept(new HttpRequest('POST', '/test', {}, { headers: new HttpHeaders().set('X-XSRF-TOKEN', 'blah') }), backend)
                .subscribe();
            var req = backend.expectOne('/test');
            expect(req.request.headers.get('X-XSRF-TOKEN')).toEqual('blah');
            req.flush({});
        });
        it('does not set the header for a null token', function () {
            var interceptor = new HttpXsrfInterceptor(new SampleTokenExtractor(null), 'X-XSRF-TOKEN');
            interceptor.intercept(new HttpRequest('POST', '/test', {}), backend).subscribe();
            var req = backend.expectOne('/test');
            expect(req.request.headers.has('X-XSRF-TOKEN')).toEqual(false);
            req.flush({});
        });
        afterEach(function () { backend.verify(); });
    });
    describe('HttpXsrfCookieExtractor', function () {
        var document;
        var extractor;
        beforeEach(function () {
            document = {
                cookie: 'XSRF-TOKEN=test',
            };
            extractor = new HttpXsrfCookieExtractor(document, 'browser', 'XSRF-TOKEN');
        });
        it('parses the cookie from document.cookie', function () { expect(extractor.getToken()).toEqual('test'); });
        it('does not re-parse if document.cookie has not changed', function () {
            expect(extractor.getToken()).toEqual('test');
            expect(extractor.getToken()).toEqual('test');
            expect(extractor.parseCount).toEqual(1);
        });
        it('re-parses if document.cookie changes', function () {
            expect(extractor.getToken()).toEqual('test');
            document['cookie'] = 'XSRF-TOKEN=blah';
            expect(extractor.getToken()).toEqual('blah');
            expect(extractor.parseCount).toEqual(2);
        });
    });
}
//# sourceMappingURL=xsrf_spec.js.map