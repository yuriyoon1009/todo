{"version":3,"file":"xhr.js","sourceRoot":"","sources":["../../src/xhr.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Observer} from 'rxjs/Observer';\n\nimport {HttpBackend} from './backend';\nimport {HttpHeaders} from './headers';\nimport {HttpRequest} from './request';\nimport {HttpDownloadProgressEvent, HttpErrorResponse, HttpEvent, HttpEventType, HttpHeaderResponse, HttpJsonParseError, HttpResponse, HttpUploadProgressEvent} from './response';\n\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n */\nfunction getResponseUrl(xhr: any): string|null {\n  if ('responseURL' in xhr && xhr.responseURL) {\n    return xhr.responseURL;\n  }\n  if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n    return xhr.getResponseHeader('X-Request-URL');\n  }\n  return null;\n}\n\n/**\n * A wrapper around the `XMLHttpRequest` constructor.\n *\n * @stable\n */\nexport abstract class XhrFactory { abstract build(): XMLHttpRequest; }\n\n/**\n * A factory for @{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.\n *\n * @stable\n */\n@Injectable()\nexport class BrowserXhr implements XhrFactory {\n  constructor() {}\n  build(): any { return <any>(new XMLHttpRequest()); }\n}\n\n/**\n * Tracks a response from the server that does not yet have a body.\n */\ninterface PartialResponse {\n  headers: HttpHeaders;\n  status: number;\n  statusText: string;\n  url: string;\n}\n\n/**\n * An `HttpBackend` which uses the XMLHttpRequest API to send\n * requests to a backend server.\n *\n * @stable\n */\n@Injectable()\nexport class HttpXhrBackend implements HttpBackend {\n  constructor(private xhrFactory: XhrFactory) {}\n\n  /**\n   * Process a request and return a stream of response events.\n   */\n  handle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    // Quick check to give a better error message when a user attempts to use\n    // HttpClient.jsonp() without installing the JsonpClientModule\n    if (req.method === 'JSONP') {\n      throw new Error(`Attempted to construct Jsonp request without JsonpClientModule installed.`);\n    }\n\n    // Everything happens on Observable subscription.\n    return new Observable((observer: Observer<HttpEvent<any>>) => {\n      // Start by setting up the XHR object with request method, URL, and withCredentials flag.\n      const xhr = this.xhrFactory.build();\n      xhr.open(req.method, req.urlWithParams);\n      if (!!req.withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      // Add all the requested headers.\n      req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n\n      // Add an Accept header if one isn't present already.\n      if (!req.headers.has('Accept')) {\n        xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');\n      }\n\n      // Auto-detect the Content-Type header if one isn't present already.\n      if (!req.headers.has('Content-Type')) {\n        const detectedType = req.detectContentTypeHeader();\n        // Sometimes Content-Type detection fails.\n        if (detectedType !== null) {\n          xhr.setRequestHeader('Content-Type', detectedType);\n        }\n      }\n\n      // Set the responseType if one was requested.\n      if (req.responseType) {\n        const responseType = req.responseType.toLowerCase();\n\n        // JSON responses need to be processed as text. This is because if the server\n        // returns an XSSI-prefixed JSON response, the browser will fail to parse it,\n        // xhr.response will be null, and xhr.responseText cannot be accessed to\n        // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON\n        // is parsed by first requesting text and then applying JSON.parse.\n        xhr.responseType = ((responseType !== 'json') ? responseType : 'text') as any;\n      }\n\n      // Serialize the request body if one is present. If not, this will be set to null.\n      const reqBody = req.serializeBody();\n\n      // If progress events are enabled, response headers will be delivered\n      // in two events - the HttpHeaderResponse event and the full HttpResponse\n      // event. However, since response headers don't change in between these\n      // two events, it doesn't make sense to parse them twice. So headerResponse\n      // caches the data extracted from the response whenever it's first parsed,\n      // to ensure parsing isn't duplicated.\n      let headerResponse: HttpHeaderResponse|null = null;\n\n      // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n      // state, and memoizes it into headerResponse.\n      const partialFromXhr = (): HttpHeaderResponse => {\n        if (headerResponse !== null) {\n          return headerResponse;\n        }\n\n        // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).\n        const status: number = xhr.status === 1223 ? 204 : xhr.status;\n        const statusText = xhr.statusText || 'OK';\n\n        // Parse headers from XMLHttpRequest - this step is lazy.\n        const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n\n        // Read the response URL from the XMLHttpResponse instance and fall back on the\n        // request URL.\n        const url = getResponseUrl(xhr) || req.url;\n\n        // Construct the HttpHeaderResponse and memoize it.\n        headerResponse = new HttpHeaderResponse({headers, status, statusText, url});\n        return headerResponse;\n      };\n\n      // Next, a few closures are defined for the various events which XMLHttpRequest can\n      // emit. This allows them to be unregistered as event listeners later.\n\n      // First up is the load event, which represents a response being fully available.\n      const onLoad = () => {\n        // Read response state from the memoized partial data.\n        let {headers, status, statusText, url} = partialFromXhr();\n\n        // The body will be read out if present.\n        let body: any|null = null;\n\n        if (status !== 204) {\n          // Use XMLHttpRequest.response if set, responseText otherwise.\n          body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;\n        }\n\n        // Normalize another potential bug (this one comes from CORS).\n        if (status === 0) {\n          status = !!body ? 200 : 0;\n        }\n\n        // ok determines whether the response will be transmitted on the event or\n        // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n        // but a successful status code can still result in an error if the user\n        // asked for JSON data and the body cannot be parsed as such.\n        let ok = status >= 200 && status < 300;\n\n        // Check whether the body needs to be parsed as JSON (in many cases the browser\n        // will have done that already).\n        if (ok && req.responseType === 'json' && typeof body === 'string') {\n          // Attempt the parse. If it fails, a parse error should be delivered to the user.\n          body = body.replace(XSSI_PREFIX, '');\n          try {\n            body = JSON.parse(body);\n          } catch (error) {\n            // Even though the response status was 2xx, this is still an error.\n            ok = false;\n            // The parse error contains the text of the body that failed to parse.\n            body = { error, text: body } as HttpJsonParseError;\n          }\n        } else if (!ok && req.responseType === 'json' && typeof body === 'string') {\n          try {\n            // Attempt to parse the body as JSON.\n            body = JSON.parse(body);\n          } catch (error) {\n            // Cannot be certain that the body was meant to be parsed as JSON.\n            // Leave the body as a string.\n          }\n        }\n\n        if (ok) {\n          // A successful response is delivered on the event stream.\n          observer.next(new HttpResponse({\n            body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n          // The full body has been received and delivered, no further events\n          // are possible. This request is complete.\n          observer.complete();\n        } else {\n          // An unsuccessful request is delivered on the error channel.\n          observer.error(new HttpErrorResponse({\n            // The error in this case is the response body (error from the server).\n            error: body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n        }\n      };\n\n      // The onError callback is called when something goes wrong at the network level.\n      // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n      // transmitted on the error channel.\n      const onError = (error: ErrorEvent) => {\n        const res = new HttpErrorResponse({\n          error,\n          status: xhr.status || 0,\n          statusText: xhr.statusText || 'Unknown Error',\n        });\n        observer.error(res);\n      };\n\n      // The sentHeaders flag tracks whether the HttpResponseHeaders event\n      // has been sent on the stream. This is necessary to track if progress\n      // is enabled since the event will be sent on only the first download\n      // progerss event.\n      let sentHeaders = false;\n\n      // The download progress event handler, which is only registered if\n      // progress events are enabled.\n      const onDownProgress = (event: ProgressEvent) => {\n        // Send the HttpResponseHeaders event if it hasn't been sent already.\n        if (!sentHeaders) {\n          observer.next(partialFromXhr());\n          sentHeaders = true;\n        }\n\n        // Start building the download progress event to deliver on the response\n        // event stream.\n        let progressEvent: HttpDownloadProgressEvent = {\n          type: HttpEventType.DownloadProgress,\n          loaded: event.loaded,\n        };\n\n        // Set the total number of bytes in the event if it's available.\n        if (event.lengthComputable) {\n          progressEvent.total = event.total;\n        }\n\n        // If the request was for text content and a partial response is\n        // available on XMLHttpRequest, include it in the progress event\n        // to allow for streaming reads.\n        if (req.responseType === 'text' && !!xhr.responseText) {\n          progressEvent.partialText = xhr.responseText;\n        }\n\n        // Finally, fire the event.\n        observer.next(progressEvent);\n      };\n\n      // The upload progress event handler, which is only registered if\n      // progress events are enabled.\n      const onUpProgress = (event: ProgressEvent) => {\n        // Upload progress events are simpler. Begin building the progress\n        // event.\n        let progress: HttpUploadProgressEvent = {\n          type: HttpEventType.UploadProgress,\n          loaded: event.loaded,\n        };\n\n        // If the total number of bytes being uploaded is available, include\n        // it.\n        if (event.lengthComputable) {\n          progress.total = event.total;\n        }\n\n        // Send the event.\n        observer.next(progress);\n      };\n\n      // By default, register for load and error events.\n      xhr.addEventListener('load', onLoad);\n      xhr.addEventListener('error', onError);\n\n      // Progress events are only enabled if requested.\n      if (req.reportProgress) {\n        // Download progress is always enabled if requested.\n        xhr.addEventListener('progress', onDownProgress);\n\n        // Upload progress depends on whether there is a body to upload.\n        if (reqBody !== null && xhr.upload) {\n          xhr.upload.addEventListener('progress', onUpProgress);\n        }\n      }\n\n      // Fire the request, and notify the event stream that it was fired.\n      xhr.send(reqBody);\n      observer.next({type: HttpEventType.Sent});\n\n      // This is the return from the Observable function, which is the\n      // request cancellation handler.\n      return () => {\n        // On a cancellation, remove all registered event listeners.\n        xhr.removeEventListener('error', onError);\n        xhr.removeEventListener('load', onLoad);\n        if (req.reportProgress) {\n          xhr.removeEventListener('progress', onDownProgress);\n          if (reqBody !== null && xhr.upload) {\n            xhr.upload.removeEventListener('progress', onUpProgress);\n          }\n        }\n\n        // Finally, abort the in-flight request.\n        xhr.abort();\n      };\n    });\n  }\n}\n"]}