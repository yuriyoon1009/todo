{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {of } from 'rxjs/observable/of';\nimport {concatMap} from 'rxjs/operator/concatMap';\nimport {filter} from 'rxjs/operator/filter';\nimport {map} from 'rxjs/operator/map';\n\nimport { \n  HttpHandler,\n  HttpHeaders,\n  HttpRequest,\n  HttpEvent,\n  HttpResponse,\n  HttpParams,\n  HttpClient,\n } from '@angular/common/http';\n\n// import {HttpHandler} from './backend';\n// import {HttpHeaders} from './headers';\nimport { \n  HttpParamsOptions,\n  WebHttpUrlEncodingCodec,\n } from './params';\n// import {HttpRequest} from './request';\n// import {HttpEvent, HttpResponse} from './response';\n\n\n/**\n * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. Basically, this clones the object and adds the body.\n */\nfunction addBody<T>(\n    options: {\n      headers?: HttpHeaders | {[header: string]: string | string[]},\n      observe?: HttpObserve,\n      params?: HttpParams | {[param: string]: string | string[]},\n      reportProgress?: boolean,\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n      withCredentials?: boolean,\n    },\n    body: T | null): any {\n  return {\n    body,\n    headers: options.headers,\n    observe: options.observe,\n    params: options.params,\n    reportProgress: options.reportProgress,\n    responseType: options.responseType,\n    withCredentials: options.withCredentials,\n  };\n}\n\n/**\n * @stable\n */\nexport type HttpObserve = 'body' | 'events' | 'response';\n\n/**\n * Perform HTTP requests.\n *\n * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.\n * Each request method has multiple signatures, and the return type varies according to which\n * signature is called (mainly the values of `observe` and `responseType`).\n *\n * @stable\n */\n@Injectable()\nexport class WebHttpClient {\n  constructor(private handler: HttpHandler) {\n  }\n\n  /**\n   * Send the given `HttpRequest` and return a stream of `HttpEvents`.\n   */\n  request<R>(req: HttpRequest<any>): Observable<HttpEvent<R>>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    params?: HttpParams|{[param: string]: string | string[]},\n    observe: 'events', reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a request which interprets the body as an `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    reportProgress?: boolean,\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<any>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    reportProgress?: boolean,\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<R>>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    reportProgress?: boolean,\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    reportProgress?: boolean,\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<R>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    reportProgress?: boolean,\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    reportProgress?: boolean,\n    withCredentials?: boolean,\n  }): Observable<R>;\n\n  /**\n   * Construct a request in a manner where response type and requested `Observable` are not known\n   * statically.\n   *\n   * @return an `Observable` of whatever was requested, typed to `any`.\n   */\n  request(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    params?: HttpParams|{[param: string]: string | string[]},\n    observe?: HttpObserve,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  }): Observable<any>;\n\n  /**\n   * Constructs an `Observable` for a particular HTTP request that, when subscribed,\n   * fires the request through the chain of registered interceptors and on to the\n   * server.\n   *\n   * This method can be called in one of two ways. Either an `HttpRequest`\n   * instance can be passed directly as the only parameter, or a method can be\n   * passed as the first parameter, a string URL as the second, and an\n   * options hash as the third.\n   *\n   * If a `HttpRequest` object is passed directly, an `Observable` of the\n   * raw `HttpEvent` stream will be returned.\n   *\n   * If a request is instead built by providing a URL, the options object\n   * determines the return type of `request()`. In addition to configuring\n   * request parameters such as the outgoing headers and/or the body, the options\n   * hash specifies two key pieces of information about the request: the\n   * `responseType` and what to `observe`.\n   *\n   * The `responseType` value determines how a successful response body will be\n   * parsed. If `responseType` is the default `json`, a type interface for the\n   * resulting object may be passed as a type parameter to `request()`.\n   *\n   * The `observe` value determines the return type of `request()`, based on what\n   * the consumer is interested in observing. A value of `events` will return an\n   * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,\n   * including progress events by default. A value of `response` will return an\n   * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`\n   * depends on the `responseType` and any optionally provided type parameter.\n   * A value of `body` will return an `Observable<T>` with the same `T` body type.\n   */\n  request(first: string|HttpRequest<any>, url?: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    let req: HttpRequest<any>;\n    // Firstly, check whether the primary argument is an instance of `HttpRequest`.\n    if (first instanceof HttpRequest) {\n      // It is. The other arguments must be undefined (per the signatures) and can be\n      // ignored.\n      req = first as HttpRequest<any>;\n    } else {\n      // It's a string, so it represents a URL. Construct a request based on it,\n      // and incorporate the remaining arguments (assuming GET unless a method is\n      // provided.\n\n      // Figure out the headers.\n      let headers: HttpHeaders|undefined = undefined;\n      if (!!options.headers !== undefined) {\n        if (options.headers instanceof HttpHeaders) {\n          headers = options.headers;\n        } else {\n          headers = new HttpHeaders(options.headers);\n        }\n      }\n\n      // Sort out parameters.\n      let params: HttpParams|undefined = undefined;\n      if (!!options.params) {\n        if (options.params instanceof HttpParams) {\n          const paramsObject: {[param: string]: string[] | string } = {};\n          for (const param of options.params.keys()) {\n            paramsObject[param] = options.params.getAll(param) || '';\n          }\n          params = new HttpParams({\n            fromObject: paramsObject,\n            encoder: new WebHttpUrlEncodingCodec(),\n          });\n        } else {\n          params = new HttpParams({ \n            fromObject: options.params,\n            encoder: new WebHttpUrlEncodingCodec(),\n           } as HttpParamsOptions);\n        }\n      }\n\n      // Construct the request.\n      req = new HttpRequest(first, url !, options.body || null, {\n        headers,\n        params,\n        reportProgress: options.reportProgress,\n        // By default, JSON is assumed to be returned for all calls.\n        responseType: options.responseType || 'json',\n        withCredentials: options.withCredentials,\n      });\n    }\n\n    // Start with an Observable.of() the initial request, and run the handler (which\n    // includes all interceptors) inside a concatMap(). This way, the handler runs\n    // inside an Observable chain, which causes interceptors to be re-run on every\n    // subscription (this also makes retries re-run the handler, including interceptors).\n    const events$: Observable<HttpEvent<any>> =\n        concatMap.call(of (req), (req: HttpRequest<any>) => this.handler.handle(req));\n\n    // If coming via the API signature which accepts a previously constructed HttpRequest,\n    // the only option is to get the event stream. Otherwise, return the event stream if\n    // that is what was requested.\n    if (first instanceof HttpRequest || options.observe === 'events') {\n      return events$;\n    }\n\n    // The requested stream contains either the full response or the body. In either\n    // case, the first step is to filter the event stream to extract a stream of\n    // responses(s).\n    const res$: Observable<HttpResponse<any>> =\n        filter.call(events$, (event: HttpEvent<any>) => event instanceof HttpResponse);\n\n    // Decide which stream to return.\n    switch (options.observe || 'body') {\n      case 'body':\n        // The requested stream is the body. Map the response stream to the response\n        // body. This could be done more simply, but a misbehaving interceptor might\n        // transform the response body into a different format and ignore the requested\n        // responseType. Guard against this by validating that the response is of the\n        // requested type.\n        switch (req.responseType) {\n          case 'arraybuffer':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is an ArrayBuffer.\n              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                throw new Error('Response is not an ArrayBuffer.');\n              }\n              return res.body;\n            });\n          case 'blob':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is a Blob.\n              if (res.body !== null && !(res.body instanceof Blob)) {\n                throw new Error('Response is not a Blob.');\n              }\n              return res.body;\n            });\n          case 'text':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is a string.\n              if (res.body !== null && typeof res.body !== 'string') {\n                throw new Error('Response is not a string.');\n              }\n              return res.body;\n            });\n          case 'json':\n          default:\n            // No validation needed for JSON responses, as they can be of any type.\n            return map.call(res$, (res: HttpResponse<any>) => res.body);\n        }\n      case 'response':\n        // The response stream was requested directly, so return it.\n        return res$;\n      default:\n        // Guard against new future observe types being added.\n        throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n    }\n  }\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  delete<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  delete<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  delete (url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  delete<T>(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * DELETE request to be executed on the server. See the individual overloads for\n   * details of `delete()`'s return type based on the provided options.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('DELETE', url, options as any);\n  }\n\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  get<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  get<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  get(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  get<T>(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * GET request to be executed on the server. See the individual overloads for\n   * details of `get()`'s return type based on the provided options.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('GET', url, options as any);\n  }\n\n\n  /**\n   * Construct a HEAD request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n\n    /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  }): Observable<ArrayBuffer>;\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  head<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  head<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  head(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  head<T>(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * HEAD request to be executed on the server. See the individual overloads for\n   * details of `head()`'s return type based on the provided options.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('HEAD', url, options as any);\n  }\n\n  /**\n   * Construct a JSONP request for the given URL and name of the callback parameter.\n   *\n   * @return an `Observable` of the response object as an `Object`\n   */\n  jsonp(url: string, callbackParam: string): Observable<Object>;\n\n  /**\n   * Construct a JSONP request for the given URL and name of the callback parameter.\n   *\n   * @return an `Observable` of the response object as type `T`.\n   */\n  jsonp<T>(url: string, callbackParam: string): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause a request\n   * with the special method `JSONP` to be dispatched via the interceptor pipeline.\n   *\n   * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).\n   * If no such interceptor is reached, then the `JSONP` request will likely be\n   * rejected by the configured backend.\n   */\n  jsonp<T>(url: string, callbackParam: string): Observable<T> {\n    return this.request<any>('JSONP', url, {\n      params: new HttpParams({\n        encoder: new WebHttpUrlEncodingCodec(),\n      }).append(callbackParam, 'JSONP_CALLBACK'),\n      observe: 'body',\n      responseType: 'json',\n    });\n  }\n\n  /**\n   * Make an OPTIONS request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a OPTIONS request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  options<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  options<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  options(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  options<T>(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * OPTIONS request to be executed on the server. See the individual overloads for\n   * details of `options()`'s return type based on the provided options.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('OPTIONS', url, options as any);\n  }\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  patch<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  patch<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  patch(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  patch<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * PATCH request to be executed on the server. See the individual overloads for\n   * details of `patch()`'s return type based on the provided options.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('PATCH', url, addBody(options, body));\n  }\n\n  /**\n   * Construct a POST request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  post<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a POST request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  post<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  post(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  post<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * POST request to be executed on the server. See the individual overloads for\n   * details of `post()`'s return type based on the provided options.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('POST', url, addBody(options, body));\n  }\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  put<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events', responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  put<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  put(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  put<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * POST request to be executed on the server. See the individual overloads for\n   * details of `post()`'s return type based on the provided options.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('PUT', url, addBody(options, body));\n  }\n}"]}