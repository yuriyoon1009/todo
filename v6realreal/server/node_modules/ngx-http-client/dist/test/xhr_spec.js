/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { describe, it } from '@angular/core/testing/src/testing_internal';
import { HttpRequest } from '../src/request';
import { HttpErrorResponse, HttpEventType, HttpResponse } from '../src/response';
import { HttpXhrBackend } from '../src/xhr';
import { MockXhrFactory } from './xhr_mock';
function trackEvents(obs) {
    var events = [];
    obs.subscribe(function (event) { return events.push(event); }, function (err) { return events.push(err); });
    return events;
}
var TEST_POST = new HttpRequest('POST', '/test', 'some body', {
    responseType: 'text',
});
export function main() {
    describe('XhrBackend', function () {
        var factory = null;
        var backend = null;
        beforeEach(function () {
            factory = new MockXhrFactory();
            backend = new HttpXhrBackend(factory);
        });
        it('emits status immediately', function () {
            var events = trackEvents(backend.handle(TEST_POST));
            expect(events.length).toBe(1);
            expect(events[0].type).toBe(HttpEventType.Sent);
        });
        it('sets method, url, and responseType correctly', function () {
            backend.handle(TEST_POST).subscribe();
            expect(factory.mock.method).toBe('POST');
            expect(factory.mock.responseType).toBe('text');
            expect(factory.mock.url).toBe('/test');
        });
        it('sets outgoing body correctly', function () {
            backend.handle(TEST_POST).subscribe();
            expect(factory.mock.body).toBe('some body');
        });
        it('sets outgoing headers, including default headers', function () {
            var post = TEST_POST.clone({
                setHeaders: {
                    'Test': 'Test header',
                },
            });
            backend.handle(post).subscribe();
            expect(factory.mock.mockHeaders).toEqual({
                'Test': 'Test header',
                'Accept': 'application/json, text/plain, */*',
                'Content-Type': 'text/plain',
            });
        });
        it('sets outgoing headers, including overriding defaults', function () {
            var setHeaders = {
                'Test': 'Test header',
                'Accept': 'text/html',
                'Content-Type': 'text/css',
            };
            backend.handle(TEST_POST.clone({ setHeaders: setHeaders })).subscribe();
            expect(factory.mock.mockHeaders).toEqual(setHeaders);
        });
        it('passes withCredentials through', function () {
            backend.handle(TEST_POST.clone({ withCredentials: true })).subscribe();
            expect(factory.mock.withCredentials).toBe(true);
        });
        it('handles a text response', function () {
            var events = trackEvents(backend.handle(TEST_POST));
            factory.mock.mockFlush(200, 'OK', 'some response');
            expect(events.length).toBe(2);
            expect(events[1].type).toBe(HttpEventType.Response);
            expect(events[1] instanceof HttpResponse).toBeTruthy();
            var res = events[1];
            expect(res.body).toBe('some response');
            expect(res.status).toBe(200);
            expect(res.statusText).toBe('OK');
        });
        it('handles a json response', function () {
            var events = trackEvents(backend.handle(TEST_POST.clone({ responseType: 'json' })));
            factory.mock.mockFlush(200, 'OK', JSON.stringify({ data: 'some data' }));
            expect(events.length).toBe(2);
            var res = events[1];
            expect(res.body.data).toBe('some data');
        });
        it('handles a json error response', function () {
            var events = trackEvents(backend.handle(TEST_POST.clone({ responseType: 'json' })));
            factory.mock.mockFlush(500, 'Error', JSON.stringify({ data: 'some data' }));
            expect(events.length).toBe(2);
            var res = events[1];
            expect(res.error.data).toBe('some data');
        });
        it('handles a json string response', function () {
            var events = trackEvents(backend.handle(TEST_POST.clone({ responseType: 'json' })));
            expect(factory.mock.responseType).toEqual('text');
            factory.mock.mockFlush(200, 'OK', JSON.stringify('this is a string'));
            expect(events.length).toBe(2);
            var res = events[1];
            expect(res.body).toEqual('this is a string');
        });
        it('handles a json response with an XSSI prefix', function () {
            var events = trackEvents(backend.handle(TEST_POST.clone({ responseType: 'json' })));
            factory.mock.mockFlush(200, 'OK', ')]}\'\n' + JSON.stringify({ data: 'some data' }));
            expect(events.length).toBe(2);
            var res = events[1];
            expect(res.body.data).toBe('some data');
        });
        it('emits unsuccessful responses via the error path', function (done) {
            backend.handle(TEST_POST).subscribe(undefined, function (err) {
                expect(err instanceof HttpErrorResponse).toBe(true);
                expect(err.error).toBe('this is the error');
                done();
            });
            factory.mock.mockFlush(400, 'Bad Request', 'this is the error');
        });
        it('emits real errors via the error path', function (done) {
            backend.handle(TEST_POST).subscribe(undefined, function (err) {
                expect(err instanceof HttpErrorResponse).toBe(true);
                expect(err.error instanceof Error);
                done();
            });
            factory.mock.mockErrorEvent(new Error('blah'));
        });
        describe('progress events', function () {
            it('are emitted for download progress', function (done) {
                backend.handle(TEST_POST.clone({ reportProgress: true })).toArray().subscribe(function (events) {
                    expect(events.map(function (event) { return event.type; })).toEqual([
                        HttpEventType.Sent,
                        HttpEventType.ResponseHeader,
                        HttpEventType.DownloadProgress,
                        HttpEventType.DownloadProgress,
                        HttpEventType.Response,
                    ]);
                    var _a = [
                        events[2], events[3],
                        events[4]
                    ], progress1 = _a[0], progress2 = _a[1], response = _a[2];
                    expect(progress1.partialText).toBe('down');
                    expect(progress1.loaded).toBe(100);
                    expect(progress1.total).toBe(300);
                    expect(progress2.partialText).toBe('download');
                    expect(progress2.loaded).toBe(200);
                    expect(progress2.total).toBe(300);
                    expect(response.body).toBe('downloaded');
                    done();
                });
                factory.mock.responseText = 'down';
                factory.mock.mockDownloadProgressEvent(100, 300);
                factory.mock.responseText = 'download';
                factory.mock.mockDownloadProgressEvent(200, 300);
                factory.mock.mockFlush(200, 'OK', 'downloaded');
            });
            it('are emitted for upload progress', function (done) {
                backend.handle(TEST_POST.clone({ reportProgress: true })).toArray().subscribe(function (events) {
                    expect(events.map(function (event) { return event.type; })).toEqual([
                        HttpEventType.Sent,
                        HttpEventType.UploadProgress,
                        HttpEventType.UploadProgress,
                        HttpEventType.Response,
                    ]);
                    var _a = [
                        events[1],
                        events[2],
                    ], progress1 = _a[0], progress2 = _a[1];
                    expect(progress1.loaded).toBe(100);
                    expect(progress1.total).toBe(300);
                    expect(progress2.loaded).toBe(200);
                    expect(progress2.total).toBe(300);
                    done();
                });
                factory.mock.mockUploadProgressEvent(100, 300);
                factory.mock.mockUploadProgressEvent(200, 300);
                factory.mock.mockFlush(200, 'OK', 'Done');
            });
            it('are emitted when both upload and download progress are available', function (done) {
                backend.handle(TEST_POST.clone({ reportProgress: true })).toArray().subscribe(function (events) {
                    expect(events.map(function (event) { return event.type; })).toEqual([
                        HttpEventType.Sent,
                        HttpEventType.UploadProgress,
                        HttpEventType.ResponseHeader,
                        HttpEventType.DownloadProgress,
                        HttpEventType.Response,
                    ]);
                    done();
                });
                factory.mock.mockUploadProgressEvent(100, 300);
                factory.mock.mockDownloadProgressEvent(200, 300);
                factory.mock.mockFlush(200, 'OK', 'Done');
            });
            it('are emitted even if length is not computable', function (done) {
                backend.handle(TEST_POST.clone({ reportProgress: true })).toArray().subscribe(function (events) {
                    expect(events.map(function (event) { return event.type; })).toEqual([
                        HttpEventType.Sent,
                        HttpEventType.UploadProgress,
                        HttpEventType.ResponseHeader,
                        HttpEventType.DownloadProgress,
                        HttpEventType.Response,
                    ]);
                    done();
                });
                factory.mock.mockUploadProgressEvent(100);
                factory.mock.mockDownloadProgressEvent(200);
                factory.mock.mockFlush(200, 'OK', 'Done');
            });
            it('include ResponseHeader with headers and status', function (done) {
                backend.handle(TEST_POST.clone({ reportProgress: true })).toArray().subscribe(function (events) {
                    expect(events.map(function (event) { return event.type; })).toEqual([
                        HttpEventType.Sent,
                        HttpEventType.ResponseHeader,
                        HttpEventType.DownloadProgress,
                        HttpEventType.Response,
                    ]);
                    var partial = events[1];
                    expect(partial.headers.get('Content-Type')).toEqual('text/plain');
                    expect(partial.headers.get('Test')).toEqual('Test header');
                    done();
                });
                factory.mock.mockResponseHeaders = 'Test: Test header\nContent-Type: text/plain\n';
                factory.mock.mockDownloadProgressEvent(200);
                factory.mock.mockFlush(200, 'OK', 'Done');
            });
            it('are unsubscribed along with the main request', function () {
                var sub = backend.handle(TEST_POST.clone({ reportProgress: true })).subscribe();
                expect(factory.mock.listeners.progress).not.toBeUndefined();
                sub.unsubscribe();
                expect(factory.mock.listeners.progress).toBeUndefined();
            });
            it('do not cause headers to be re-parsed on main response', function (done) {
                backend.handle(TEST_POST.clone({ reportProgress: true })).toArray().subscribe(function (events) {
                    events
                        .filter(function (event) { return event.type === HttpEventType.Response ||
                        event.type === HttpEventType.ResponseHeader; })
                        .map(function (event) { return event; })
                        .forEach(function (event) {
                        expect(event.status).toBe(203);
                        expect(event.headers.get('Test')).toEqual('This is a test');
                    });
                    done();
                });
                factory.mock.mockResponseHeaders = 'Test: This is a test\n';
                factory.mock.status = 203;
                factory.mock.mockDownloadProgressEvent(100, 300);
                factory.mock.mockResponseHeaders = 'Test: should never be read\n';
                factory.mock.mockFlush(203, 'OK', 'Testing 1 2 3');
            });
        });
        describe('gets response URL', function () {
            it('from XHR.responsesURL', function (done) {
                backend.handle(TEST_POST).toArray().subscribe(function (events) {
                    expect(events.length).toBe(2);
                    expect(events[1].type).toBe(HttpEventType.Response);
                    var response = events[1];
                    expect(response.url).toBe('/response/url');
                    done();
                });
                factory.mock.responseURL = '/response/url';
                factory.mock.mockFlush(200, 'OK', 'Test');
            });
            it('from X-Request-URL header if XHR.responseURL is not present', function (done) {
                backend.handle(TEST_POST).toArray().subscribe(function (events) {
                    expect(events.length).toBe(2);
                    expect(events[1].type).toBe(HttpEventType.Response);
                    var response = events[1];
                    expect(response.url).toBe('/response/url');
                    done();
                });
                factory.mock.mockResponseHeaders = 'X-Request-URL: /response/url\n';
                factory.mock.mockFlush(200, 'OK', 'Test');
            });
            it('falls back on Request.url if neither are available', function (done) {
                backend.handle(TEST_POST).toArray().subscribe(function (events) {
                    expect(events.length).toBe(2);
                    expect(events[1].type).toBe(HttpEventType.Response);
                    var response = events[1];
                    expect(response.url).toBe('/test');
                    done();
                });
                factory.mock.mockFlush(200, 'OK', 'Test');
            });
        });
        describe('corrects for quirks', function () {
            it('by normalizing 1223 status to 204', function (done) {
                backend.handle(TEST_POST).toArray().subscribe(function (events) {
                    expect(events.length).toBe(2);
                    expect(events[1].type).toBe(HttpEventType.Response);
                    var response = events[1];
                    expect(response.status).toBe(204);
                    done();
                });
                factory.mock.mockFlush(1223, 'IE Special Status', 'Test');
            });
            it('by normalizing 0 status to 200 if a body is present', function (done) {
                backend.handle(TEST_POST).toArray().subscribe(function (events) {
                    expect(events.length).toBe(2);
                    expect(events[1].type).toBe(HttpEventType.Response);
                    var response = events[1];
                    expect(response.status).toBe(200);
                    done();
                });
                factory.mock.mockFlush(0, 'CORS 0 status', 'Test');
            });
            it('by leaving 0 status as 0 if a body is not present', function (done) {
                backend.handle(TEST_POST).toArray().subscribe(undefined, function (error) {
                    expect(error.status).toBe(0);
                    done();
                });
                factory.mock.mockFlush(0, 'CORS 0 status');
            });
        });
    });
}
//# sourceMappingURL=xhr_spec.js.map