/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HttpHeaders } from '../src/headers';
var MockXhrFactory = /** @class */ (function () {
    function MockXhrFactory() {
    }
    MockXhrFactory.prototype.build = function () { return (this.mock = new MockXMLHttpRequest()); };
    return MockXhrFactory;
}());
export { MockXhrFactory };
var MockXMLHttpRequestUpload = /** @class */ (function () {
    function MockXMLHttpRequestUpload(mock) {
        this.mock = mock;
    }
    MockXMLHttpRequestUpload.prototype.addEventListener = function (event, handler) {
        this.mock.addEventListener('uploadProgress', handler);
    };
    MockXMLHttpRequestUpload.prototype.removeEventListener = function (event, handler) {
        this.mock.removeEventListener('uploadProgress');
    };
    return MockXMLHttpRequestUpload;
}());
export { MockXMLHttpRequestUpload };
var MockXMLHttpRequest = /** @class */ (function () {
    function MockXMLHttpRequest() {
        this.mockHeaders = {};
        this.mockAborted = false;
        // Directly settable interface.
        this.withCredentials = false;
        this.responseType = 'text';
        // Mocked response interface.
        this.response = undefined;
        this.responseText = undefined;
        this.responseURL = null;
        this.status = 0;
        this.statusText = '';
        this.mockResponseHeaders = '';
        this.listeners = {};
        this.upload = new MockXMLHttpRequestUpload(this);
    }
    MockXMLHttpRequest.prototype.open = function (method, url) {
        this.method = method;
        this.url = url;
    };
    MockXMLHttpRequest.prototype.send = function (body) { this.body = body; };
    MockXMLHttpRequest.prototype.addEventListener = function (event, handler) {
        this.listeners[event] = handler;
    };
    MockXMLHttpRequest.prototype.removeEventListener = function (event) {
        delete this.listeners[event];
    };
    MockXMLHttpRequest.prototype.setRequestHeader = function (name, value) { this.mockHeaders[name] = value; };
    MockXMLHttpRequest.prototype.getAllResponseHeaders = function () { return this.mockResponseHeaders; };
    MockXMLHttpRequest.prototype.getResponseHeader = function (header) {
        return new HttpHeaders(this.mockResponseHeaders).get(header);
    };
    MockXMLHttpRequest.prototype.mockFlush = function (status, statusText, body) {
        if (typeof body === 'string') {
            this.responseText = body;
        }
        else {
            this.response = body;
        }
        this.status = status;
        this.statusText = statusText;
        this.mockLoadEvent();
    };
    MockXMLHttpRequest.prototype.mockDownloadProgressEvent = function (loaded, total) {
        if (this.listeners.progress) {
            this.listeners.progress({ lengthComputable: total !== undefined, loaded: loaded, total: total });
        }
    };
    MockXMLHttpRequest.prototype.mockUploadProgressEvent = function (loaded, total) {
        if (this.listeners.uploadProgress) {
            this.listeners.uploadProgress({ lengthComputable: total !== undefined, loaded: loaded, total: total, });
        }
    };
    MockXMLHttpRequest.prototype.mockLoadEvent = function () {
        if (this.listeners.load) {
            this.listeners.load();
        }
    };
    MockXMLHttpRequest.prototype.mockErrorEvent = function (error) {
        if (this.listeners.error) {
            this.listeners.error(error);
        }
    };
    MockXMLHttpRequest.prototype.abort = function () { this.mockAborted = true; };
    return MockXMLHttpRequest;
}());
export { MockXMLHttpRequest };
//# sourceMappingURL=xhr_mock.js.map